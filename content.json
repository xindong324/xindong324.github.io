{"pages":[{"title":"About Me","text":"Dong Xin (董鑫)Major: Aircraft DesignPh DBeihang UniversityEmail: xindong324@buaa.edu.cnWechat: xindong324","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"My Favorite Music","text":"","link":"/2020/02/28/2020-02-28/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/08/29/hello-world/"},{"title":"Gazebo踩坑记录","text":"Gazebo 创建一个模型 Gazebo 获取模型的状态(位姿、速度等) 这个比较详细 订阅topic方法、订阅Service方法 Gazebo中获得任意model的groundtruth的pose rosbag数据记录及转换图片、视频 ArUco估计相机位姿, 另一篇 rosbag 存储话题到txt rostopic echo -b file_name.bag -p /topic_name &gt; Txt_name.txt ROS四元数、欧拉角互转 aruco_ros使用 ros c++ spinOnce 放在一进入while的第一行 ROS学习 &lt;十一&gt; Parameter的设置与查询 Sophus 中SE3初始化应用旋转矩阵而不是欧拉角否则会有问题，参见 结合SLAM十四讲的示例程序理解SE3, se(3), so(3),R, t等 ROS四元数、欧拉角互转 ROS学习笔记（三）：rosrun和runlaunch的用法, roslaunch 中使用param Tensorflow tf.layers.Dense与 tf.layers.dense的区别","link":"/2020/05/29/Gazebo%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"mavros踩坑记录","text":"mavros添加发布 tfmini 距离传感器数据 有关px4连接tfmini并配置的部分请自行到 Px4 使用手册 查找相关说明，配置成功后打开QGroundControl， 找到Mavlink Inspector， 选择 DISTANCE_SENSOR可以看到发布的高度传感器的id和数据首先说明下MAVROS px4在启动时调用 roslaunch mavros px4.launch &lt;args&gt; ，打开($ find mavros)/mavros/launch/px4.launch 12345678910111213141516171819202122232425&lt;launch&gt; &lt;!-- vim: set ft=xml noet : --&gt; &lt;!-- example launch script for PX4 based FCU's --&gt; &lt;arg name=&quot;fcu_url&quot; default=&quot;/dev/ttyACM0:57600&quot; /&gt; &lt;arg name=&quot;gcs_url&quot; default=&quot;&quot; /&gt; &lt;arg name=&quot;tgt_system&quot; default=&quot;1&quot; /&gt; &lt;arg name=&quot;tgt_component&quot; default=&quot;1&quot; /&gt; &lt;arg name=&quot;log_output&quot; default=&quot;screen&quot; /&gt; &lt;arg name=&quot;fcu_protocol&quot; default=&quot;v2.0&quot; /&gt; &lt;arg name=&quot;respawn_mavros&quot; default=&quot;false&quot; /&gt; &lt;include file=&quot;$(find mavros)/launch/node.launch&quot;&gt; &lt;arg name=&quot;pluginlists_yaml&quot; value=&quot;$(find mavros)/launch/px4_pluginlists.yaml&quot; /&gt; &lt;arg name=&quot;config_yaml&quot; value=&quot;$(find mavros)/launch/px4_config.yaml&quot; /&gt; &lt;arg name=&quot;fcu_url&quot; value=&quot;$(arg fcu_url)&quot; /&gt; &lt;arg name=&quot;gcs_url&quot; value=&quot;$(arg gcs_url)&quot; /&gt; &lt;arg name=&quot;tgt_system&quot; value=&quot;$(arg tgt_system)&quot; /&gt; &lt;arg name=&quot;tgt_component&quot; value=&quot;$(arg tgt_component)&quot; /&gt; &lt;arg name=&quot;log_output&quot; value=&quot;$(arg log_output)&quot; /&gt; &lt;arg name=&quot;fcu_protocol&quot; value=&quot;$(arg fcu_protocol)&quot; /&gt; &lt;arg name=&quot;respawn_mavros&quot; default=&quot;$(arg respawn_mavros)&quot; /&gt; &lt;/include&gt;&lt;/launch&gt; 然后定位到 node.launch 1234567891011121314151617181920212223242526&lt;launch&gt; &lt;!-- vim: set ft=xml noet : --&gt; &lt;!-- base node launch file--&gt; &lt;arg name=&quot;fcu_url&quot; /&gt; &lt;arg name=&quot;gcs_url&quot; /&gt; &lt;arg name=&quot;tgt_system&quot; /&gt; &lt;arg name=&quot;tgt_component&quot; /&gt; &lt;arg name=&quot;pluginlists_yaml&quot; /&gt; &lt;arg name=&quot;config_yaml&quot; /&gt; &lt;arg name=&quot;log_output&quot; default=&quot;screen&quot; /&gt; &lt;arg name=&quot;fcu_protocol&quot; default=&quot;v2.0&quot; /&gt; &lt;arg name=&quot;respawn_mavros&quot; default=&quot;false&quot; /&gt; &lt;node pkg=&quot;mavros&quot; type=&quot;mavros_node&quot; name=&quot;mavros&quot; required=&quot;$(eval not respawn_mavros)&quot; clear_params=&quot;true&quot; output=&quot;$(arg log_output)&quot; respawn=&quot;$(arg respawn_mavros)&quot;&gt; &lt;param name=&quot;fcu_url&quot; value=&quot;$(arg fcu_url)&quot; /&gt; &lt;param name=&quot;gcs_url&quot; value=&quot;$(arg gcs_url)&quot; /&gt; &lt;param name=&quot;target_system_id&quot; value=&quot;$(arg tgt_system)&quot; /&gt; &lt;param name=&quot;target_component_id&quot; value=&quot;$(arg tgt_component)&quot; /&gt; &lt;param name=&quot;fcu_protocol&quot; value=&quot;$(arg fcu_protocol)&quot; /&gt; &lt;!-- load blacklist, config --&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(arg pluginlists_yaml)&quot; /&gt; &lt;rosparam command=&quot;load&quot; file=&quot;$(arg config_yaml)&quot; /&gt; &lt;/node&gt;&lt;/launch&gt; 可以看出node.launch是主节点，调用了配置文件 px4_config.yaml 和插件配置文件 px4_pluginlists.yaml。 px4_config文件主要是定义了发布和订阅的节点，有关distance sensor的部分如下: 可以看出config 文件中定义了有关distance sensor的部分，但是直接运行mavros的显示信息以及rostopic list的结果如下，可以看出是没有发布distance sensor相关的topic的： 原因是px4_pluginlists文件中定义了调用的插件的黑白名单，内容如下:因此可以看出distance sensor被添加到了黑名单中，将其注释掉: 再次运行mavros，rostopic list结果如下： 可以看到config中定义的distance sensor都被发布出来了，此时，由于我们只使用到了tfmini，从QGround中看出其id为0，因此对config文件做如下修改，只保留tfmini的topic：此时再次运行mavros，rostopic list结果为：同时我们对话题进行 echo： enjoy!","link":"/2020/06/26/mavros%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"stm32 pwm 控制电机正反转","text":"STM32 的通用 TIMx (TIM2~TIM5 和 TIM9~TIM14): stm32f405rgt6(LQFP 64) 通用定时器对应的io口映射：注意，使用时发现，表格的语句上一行必须为空行，不然表格不生效。 | TIM x | CH x | io pin|:-:|:-:|:-:|| TIM2 | CH2 | PA1 PB3 || TIM2 | CH3 | PA2 PB10 || TIM2 | CH4 | PA3 PB11 || TIM3 | CH1 | PC6 PB4 PA6 || TIM3 | CH2 | PC7 PB5 PA7 || TIM3 | CH3 | PC8 PB0 || TIM3 | CH4 | PC9 PB1 || TIM5 | CH1 | PA0 || TIM5 | CH2 | PA1 || TIM5 | CH3 | PA2 || TIM5 | CH4 | PA3 || TIM4 | CH1 | PB6 || TIM4 | CH2 | PB7 || TIM4 | CH3 | PB8 || TIM4 | CH4 | PB9 || TIM10 | CH1 | PB8 || TIM11 | CH1 | PB9 || TIM12 | CH1 | PB14 || TIM12 | CH2 | PB15 || TIM13 | CH1 | PA6 || TIM14 | CH1 | PA7 | 补充：定时器中单服务函数名可以在 startup_stm32f40_41xxx.s 文件中搜索 123456789101112TIM2_IRQHandler ; TIM2 TIM3_IRQHandler ; TIM3 TIM4_IRQHandler ; TIM4 TIM5_IRQHandler ; TIM5 TIM6_DAC_IRQHandler ; TIM6 and DAC1&amp;2 underrun errors TIM7_IRQHandler ; TIM7 TIM1_BRK_TIM9_IRQHandler ; TIM1 Break and TIM9 TIM1_UP_TIM10_IRQHandler ; TIM1 Update and TIM10 TIM1_TRG_COM_TIM11_IRQHandler ; TIM1 Trigger and Commutation and TIM11TIM8_BRK_TIM12_IRQHandler ; TIM8 Break and TIM12 TIM8_UP_TIM13_IRQHandler ; TIM8 Update and TIM13 TIM8_TRG_COM_TIM14_IRQHandler ; TIM8 Trigger and Commutation and TIM14 代码实现使用PA6 PA7( TIM3的1 2 通道)产生两路pwm波，实现电机的正反转 定时器初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//TIM3 PWM 初始化 PA6 TIM3CH1 PA7 TIM3 CH2 //arr 自动重装值//psc 时钟预分频系数void TIM3_PWM_Init(u32 arr,u32 psc){ //io口配置 GPIO_InitTypeDef GPIO_InitStructure; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; TIM_OCInitTypeDef TIM_OCInitStructure; RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE); //TIM3 时钟初始化 RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); //GPIO口初始化 GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_TIM3); //GPIO复用为定时器功能 GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_TIM3); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7; //GPIO GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; //复用功能 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz; //速度100MHz GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //推挽复用输出 GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; //上拉 GPIO_Init(GPIOA,&amp;GPIO_InitStructure); //定时器配置 TIM_TimeBaseStructure.TIM_Prescaler=psc; //时钟预分频 TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; //向上计数模式 TIM_TimeBaseStructure.TIM_Period=arr; //自动重装载值 TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1; TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseStructure);//TIM3 //定时器pwm输出配置 TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; // pwm 脉宽调制1模式 即计数器值小于比较值时高电平大于时低电平 TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能 TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出比较极性高 TIM_OCInitStructure.TIM_OutputNState = TIM_OutputState_Disable; //N?????? TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset ; // 必须加，否则只有一路输出 TIM_OC1Init(TIM3, &amp;TIM_OCInitStructure); //tim3 ch1 初始化 TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure); //tim3 ch2 初始化 TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable); //使能tim3 ch1 预装载寄存器 TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); //使能tim3 ch2 预装载寄存器 TIM_ARRPreloadConfig(TIM3,ENABLE);//ARPE使能 TIM_Cmd(TIM3, ENABLE); //使能TIM3 } void Prun(u32 c1,u32 c2){ TIM_SetCompare1(TIM3,c1); // TIM3 CH1 比较，大于c1反转 TIM_SetCompare2(TIM3,c2); } 主函数 所用芯片时钟频率为84Mhz，预分频系数84，最大计数值为1000，则pwm频率为 f=84MHz/(84*1000) = 1KHz 1234567891011121314151617181920212223242526272829int main(void){ u16 PWM_HZ = 1000; // pwm运行频率 1kHz 1ms u16 PSC = 84 ; //时钟预分频系数 u32 CLK_CNT = 84000000; u32 TOTAL_CLK_HZ = CLK_CNT/PSC; // 1s 的计数次数 84M/84 = 1M hz u32 TOTAL_CNT = TOTAL_CLK_HZ/PWM_HZ; //定时器的最大计数值，决定了pwm的频率 u8 dir=1; u32 ms_delay = 500; // 10ms/doublerate u32 cnt_cmp = 80; //高电平持续8% NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //中断分组初始化 delay_init(168); //延时初始化 // uart_init(115200);//串口波特率初始化 TIM3_PWM_Init(TOTAL_CNT-1,PSC-1); //pwm初始化 while(1) //主循环 { delay_ms(ms_delay); //每0.5s反转一次 if(dir) { dir = 0; Prun(cnt_cmp,0);//dir==1 正转 } else { dir = 1; Prun(0,cnt_cmp); //dir==0 反转 } }} 部分踩坑TIM5 在四路pwm输出测试中(PA0 1 2 3), PA1持续输出不受控制的方波, 其他三路正常,暂时未找到原因,待调试.TIM3 (PC 6-9)四路pwm输出正常TIM4 (PB6-9)四路PWM输出正常","link":"/2021/01/28/stm32-pwm-%E6%8E%A7%E5%88%B6%E7%94%B5%E6%9C%BA%E6%AD%A3%E5%8F%8D%E8%BD%AC/"},{"title":"stm32 MPU9250 量程配置","text":"[toc] 参考链接： https://blog.csdn.net/cyj972628089/article/details/113293682 https://www.pianshen.com/article/6769275504/ 陀螺仪量程配置在MPU9250的数据手册中，提供了陀螺仪的数据表如下： 在表格里面，列出了当寄存器FS_SEL选择不同数值时的陀螺仪量程范围。 以四轴常用的FS_SEL=3为例，这时陀螺仪的量程为-2000到+2000，单位deg/s。 配置函数： 由于MPU6050采用的是16位带符号数作为陀螺仪测量数据输出，即数据类型是int16。所以以16进制来表示，最小的数是FFFF,由于最高位为符号位，所以相当于-7FFFF，即-32767；最大的数是7FFF，即32767。 综合上述的描述，我们可以得到，数字-32767对应-2000度每秒的陀螺仪角速度，32767对应2000度每秒的陀螺仪角速度。把32767除以2000，就可以得到16.40， 即我们说的灵敏度。 从上面的计算可知，把从陀螺仪读出的数字除以16.40，就可以换算成陀螺仪的角速度数值。举个例子，如果我们从陀螺仪读到的数字是1000，那么对应的角速度数据是1000/16.40=61度每秒。 1234567891011121314151617/**********************陀螺仪读取*****************************/void READ_MPU9250_GYRO(void){ BUF[0]=MPU9250_Read_Reg(GYRO_XOUT_L); BUF[1]=MPU9250_Read_Reg(GYRO_XOUT_H); mpu_value.Gyro[0]= (BUF[1]&lt;&lt;8)|BUF[0]; mpu_value.Gyro[0]/=16.4; //读取计算X轴数据 BUF[2]=MPU9250_Read_Reg(GYRO_YOUT_L); BUF[3]=MPU9250_Read_Reg(GYRO_YOUT_H); mpu_value.Gyro[1]= (BUF[3]&lt;&lt;8)|BUF[2]; mpu_value.Gyro[1]/=16.4; //读取计算Y轴数据 BUF[4]=MPU9250_Read_Reg(GYRO_ZOUT_L); BUF[5]=MPU9250_Read_Reg(GYRO_ZOUT_H); mpu_value.Gyro[2]= (BUF[5]&lt;&lt;8)|BUF[4]; mpu_value.Gyro[2]/=16.4; //读取计算Z轴数据} 在四轴姿态计算中，我们通常要把角度换算成弧度。我们知道2Pi代表360度，那么1度换算成弧度就是：2Pi/360=(2*3.1415926)/360=0.0174532。用倒数表示就是：1/57.30 通过上述分析，我们就可以知道，当采用量程为-2000到+2000的范围，把我们从陀螺仪获取的数据做如下处理，就可以用于四元数的姿态解算（用gyro_x来代表从陀螺仪读到的数据）: gyro_x/(16.4057.30)=gyro_x0.001064，单位为弧度每秒。 加速度计量程配置采用和陀螺仪同样的计算方法，当AFS_SEL=3时，数字-32767对应-16g，32767对应16g。把32767除以16，就可以得到2048， 即我们说的灵敏度。把从加速度计读出的数字除以2048，就可以换算成加速度的数值。举个例子，如果我们从加速度计读到的数字是1000，那么对应的加速度数据是1000/2048=0.49g。g为加速度的单位，重力加速度定义为1g, 等于9.8米每平方秒。如果需要换算为g/(m/s^2) 则对应加速度数据为data*9.8/2048 转换表格","link":"/2021/02/04/stm32-MPU9250-%E9%87%8F%E7%A8%8B%E9%85%8D%E7%BD%AE/"},{"title":"hexo配置编辑参考链接","text":"半天速成MarkDown的基本语法知识 Hexo+icarus主题配置 【Hexo搭建独立博客全纪录】（二）使用Markdown","link":"/2021/07/03/hexo%E9%85%8D%E7%BD%AE%E7%BC%96%E8%BE%91%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5/"},{"title":"px4新建机型文件：新建机型配置文件","text":"px4使用机型配置文件描述特定形式的无人机。配置文件储存在 ROMFS/px4fmu_common/init.d 文件夹中，配置文件需要调用混频文件用于描述系统的物理配置，混频文件储存在ROMFS/px4fmu_common/mixers 文件夹中. 增加一个新机型配置方法：在 init.d/airframes 文件夹中新建一个配置文件并使用一个未被占用的id来命名，并将新机型配置文件名添加到CMakeLists.txt 的相关部分，然后构建并上传。 不想创建新配置的可以使用或修改已有的配置文件并将其放置于sd卡中。 注意为了决定哪些参数要在配置文件中进行配置，可以先设置一个通用的机型然后调试仪器，之后用 param show-for-airframe 来列出改变的参数 配置文件总览px4的结构由以下几个主要代码块组成： 机型文档(用于机型描述文档和地面站) 特定机型的参数，包括增益参数 需要气动的控制器和其他应用，eg: 多旋翼/固定翼控制器，着陆检测器等等 系统的物理配置文件，也称为mixer 这些模块多数是独立的，也意味着许多配置文件共享同样的机型布局，同样应用，只是调试增益不同 注意新机型只有在重新构建的时候才会被编译 (run make clean) 配置文件一个标准的配置文件如下： 第一段是机型文档，用于生成机型参考文档和地面站机型选项 12345678910111213141516171819202122#!/bin/sh## @name Wing Wing (aka Z-84) Flying Wing## @url https://docs.px4.io/master/en/frames_plane/wing_wing_z84.html## @type Flying Wing# @class Plane## @output MAIN1 left aileron# @output MAIN2 right aileron# @output MAIN4 throttle## @output AUX1 feed-through of RC AUX1 channel# @output AUX2 feed-through of RC AUX2 channel# @output AUX3 feed-through of RC AUX3 channel## @maintainer Lorenz Meier &lt;lorenz@px4.io&gt;## @board px4_fmu-v2 exclude# @board bitcraze_crazyflie exclude# 下一段列出了机型的特定参数，包括增益： 123456789101112131415161718192021. ${R}etc/init.d/rc.fw_defaultsparam set-default BAT_N_CELLS 2param set-default FW_AIRSPD_MAX 15param set-default FW_AIRSPD_MIN 10param set-default FW_AIRSPD_TRIM 13param set-default FW_R_TC 0.3param set-default FW_P_TC 0.3param set-default FW_L1_DAMPING 0.74param set-default FW_L1_PERIOD 16param set-default FW_LND_ANG 15param set-default FW_LND_FLALT 5param set-default FW_LND_HHDIST 15param set-default FW_LND_HVIRT 13param set-default FW_LND_TLALT 5param set-default FW_THR_LND_MAX 0param set-default FW_PR_FF 0.35param set-default FW_RR_FF 0.6param set-default FW_RR_P 0.04param set-default PWM_MAIN_DISARM 1000 设定机架类型(MAV_TYPE) 1set MIXER wingwing 配置pwm输出端口(主要是设置电机电调的通道编号，如通道4为电机，会将输出pwm值设置为1000) 1set PWM_OUT 4 警告如果想反相一个通道，不要直接在遥控上面设置或者使用 RC1_REV 参数，那样只会在手动模式下实现反向，当切换到自主导航模式时通道仍然是反向的。正确的做法应该是改变 PWM_MAIN_REV1 参数或者在混频文件中改变输出scaling。 混频文件 Note对于混频的详细介绍，可以参见混频文件的文章 典型的混频文件，文件名中指定了其信息，如 wingwing.main.mix , 包括了机架类型(wingwing), 输出通道类型(.main 或 .aux), 以及混频文件类型(即.mixer)。 混频文件包含数个代码块，每块代码指定了一个输出，如果有两个舵机和一个电调，混频文件应该有至少三个代码块。 Note舵机和电机的连接顺序取决于混频文件中代码块定义的顺序。 对于MAIN1 为左升降副翼，MAIN2 为右升降副翼，MAIN3为空，MAIN4 为推力电机通道 混频器从编码范围为-10000到10000，对应实际的-1到1 1234M: 2O: 10000 10000 0 -10000 10000S: 0 0 -6000 -6000 0 -10000 10000S: 0 1 6500 6500 0 -10000 10000 从左到右参数的意义： M: 表示该通道混频器接受两个输入 O: 表示输出尺度(负向尺度 * 1，正向尺度 * 1)，偏置(这里是0)，输出范围(这里是-1到1) 如果想反相PWM信号，可以改为下面的写法： 1O: -10000 -10000 0 -10000 10000 如果是默认形式(如下代码所示)，这一行可以不写 1O: 10000 10000 0 -10000 10000 S: 表示第一个输入, 从控制组0(飞行控制组)的第一个输入通道(滚转通道，关于控制组及其通道定义参见混频器的描述)获取输入。将输入控制*0.6并反相信号(-0.6在文件中根据尺度放缩为-6000) S: 表示第二个输入，从控制组0的第二个通道(俯仰通道)获取输入，同时将俯仰输入信号乘以尺度因子0.65，无offset，全尺度输出(-1,1) Note简单说，混频的输出为 SERVO = ( (滚转输入 * -0.6 + 0) * 1 + (俯仰输入 * 0.65 + 0) * 1 ) * 1 + 0 在当前场景下，对这个飞翼的控制面在滚转时最大可以偏转60%，俯仰控制时最大可以偏转65% 最后附上全部的混频文件代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Delta-wing mixer for PX4FMU===========================Designed for Wing Wing Z-84This file defines mixers suitable for controlling a delta wing aircraft usingPX4FMU. The configuration assumes the elevon servos are connected to PX4FMUservo outputs 0 and 1 and the motor speed control to output 3. Output 2 isassumed to be unused.Inputs to the mixer come from channel group 0 (vehicle attitude), channels 0(roll), 1 (pitch) and 3 (thrust).See the README for more information on the scaler format.Elevon mixers-------------Three scalers total (output, roll, pitch).The scaling factor for roll inputs is adjusted to implement differential travelfor the elevons.This first block of code is for Servo 0...M: 2O: 10000 10000 0 -10000 10000S: 0 0 -6000 -6000 0 -10000 10000S: 0 1 6500 6500 0 -10000 10000And this is for Servo 1...M: 2O: 10000 10000 0 -10000 10000S: 0 0 -6000 -6000 0 -10000 10000S: 0 1 -6500 -6500 0 -10000 10000Note that in principle, you could implement left/right wing asymmetric mixing, but in general the two blocks of code will be numerically equal, and just differ by the sign of the third line (S: 0 1), since to roll the plane, the two ailerons must move in OPPOSITE directions.The signs of the second lines (S: 0 0) are indentical, since to pitch the plane, both servos need to move in the SAME direction.Output 2--------This mixer is empty.Z:Motor speed mixer-----------------Two scalers total (output, thrust).This mixer generates a full-range output (-1 to 1) from an input in the (0 - 1)range. Inputs below zero are treated as zero.M: 1O: 10000 10000 0 -10000 10000S: 0 3 0 20000 -10000 -10000 10000 增加一个新机型组机型组用于将相似的机型组合起来，便于在地面站进行选择，每个机型组都有一个名字，一个对应的svg格式图片来展示机型的一般形状，电机数量，螺旋桨转向 用于QGC和说明文档的各机型的原始文件是通过一个脚本从机型配置描述部分转换而来的，转换的命令为 make airframe_metadata 对于一个从属于已经存在机型组的新机型，只需要在机型配置文件中提供机型描述部分即可，这部分文件应放置于 ROMFS/px4fmu_common/init.d 如果机型是定义在一个新机型组中，需要额外做的工作是： 将机型组的svg图像添加到使用指南文档中(如果没有图像可以提供会显示默认图像)，指南文档地址： assets/airframes/types 将新机型组的名字和图像文件名的映射关系添加到 srcparser.py 文件的 GetImageName() 方法，参考如下代码： 1234567891011def GetImageName(self): &quot;&quot;&quot; Get parameter group image base name (w/o extension) &quot;&quot;&quot; if (self.name == &quot;Standard Plane&quot;): return &quot;Plane&quot; elif (self.name == &quot;Flying Wing&quot;): return &quot;FlyingWing&quot; ... ... return &quot;AirframeUnknown&quot; 更新QGC： 将该机型组的svg图像添加到src/AutopilotPlugins/Common/images 添加svg图像的索引到 qgcimages.qrc ，参考如下代码： 1234567&lt;qresource prefix=\"/qmlimages\"&gt; ... &lt;file alias=\"Airframe/AirframeSimulation\"&gt;src/AutoPilotPlugins/Common/Images/AirframeSimulation.svg&lt;/file&gt; &lt;file alias=\"Airframe/AirframeUnknown\"&gt;src/AutoPilotPlugins/Common/Images/AirframeUnknown.svg&lt;/file&gt; &lt;file alias=\"Airframe/Boat\"&gt;src/AutoPilotPlugins/Common/Images/Boat.svg&lt;/file&gt; &lt;file alias=\"Airframe/FlyingWing\"&gt;src/AutoPilotPlugins/Common/Images/FlyingWing.svg&lt;/file&gt; ... Note一旦 srcparser.py 更新，已经存在的机型原始文件会自动包含到固件中 调参参见以下链接 Multicopter PID Tuning Guide Fixed Wing PID Tuning Guide VTOL Configuration 添加新机型到QGC以下步骤会使新机型在QGC机架选择中可用： 重新编译代码(先执行 make clean, 再执行 make px4_fmu-v5_default) 启动QGC选择 Custom firmware file… 你会被要求选择.px4文件到flash(这个文件是一个压缩的JSON文件包含机架原始代码)。 定位到构建文件夹选择固件文件(PX4-Autopilot/build/px4_fmu-v5_default/px4_fmu-v5_default.px4). 点击OK开始flash固件 重启QGC QGC中可以选择新机型","link":"/2021/07/03/px4%E6%96%B0%E5%BB%BA%E6%9C%BA%E5%9E%8B%E6%96%87%E4%BB%B6%E4%B8%80%EF%BC%9A%E6%96%B0%E5%BB%BA%E6%9C%BA%E5%9E%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"}],"tags":[{"name":"Music","slug":"Music","link":"/tags/Music/"},{"name":"Gazebo","slug":"Gazebo","link":"/tags/Gazebo/"},{"name":"UAV","slug":"UAV","link":"/tags/UAV/"},{"name":"PX4","slug":"PX4","link":"/tags/PX4/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"PWM","slug":"PWM","link":"/tags/PWM/"},{"name":"MOTOR","slug":"MOTOR","link":"/tags/MOTOR/"},{"name":"STM32 UAV MPU9250","slug":"STM32-UAV-MPU9250","link":"/tags/STM32-UAV-MPU9250/"}],"categories":[{"name":"Music","slug":"Music","link":"/categories/Music/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"STM32","slug":"STM32","link":"/categories/STM32/"},{"name":"PX4","slug":"PX4","link":"/categories/PX4/"}]}